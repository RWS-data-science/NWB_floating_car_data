---
title: "NWB_FCD project"
output: html_notebook
---

Project in opdracht van NWB projectteam, uitgevoerd door RWS Datalab.

Team:  
[Martijn Koole](martijn.koole@rws.nl) - Data Scientist  
[Daan van der Maas](daan.vander.maas@rws.nl) - Data Scientist  
[Jan Quist](jan.quist@rws.nl) - Data Scientist  
[Steven van Gelder](steven.van.gelder@rws.nl) - Product manager  
[Vikash Rambaran](vikash.rambaran@rws.nl) - Product Owner  



###################################BESTANDEN AGREGREREN##############################################


#######################################EIND BESTANDEN AGREGREREN##########################################





#####################################PRE PROCESSING######################################################
#Data laden en preprocessing
Onderstaande code importeert alle benodigde libraries en functies en laadt vervolgens de gebruikte data. Er is een uitsnede gemaakt van het NWB Wegvakken bestand van 01-06-2017 rondom Gouda. Vervolgens is een zelfde uitsnede gemaakt voor de Basemap die verkregen is via BeMobile (gebaseerd op Open Street Map, OSM). De uitsnede is in eerste instantie gemaakt om de rekentijd kort te houden tijdens ontwikkelen/testen. Dat gebeurt in het script read_fcd.R. Later kunnen dezelfde scripts gebruikt worden voor om over heel Nederland verschillen te detecteren.

```{r, echo=F,cache=T,eval=F}

load("db/basemap_select.RData")
load("db/nwb_select2.RData")
```

Om het NWB bestand te kunnen vergelijken zullen deze op elkaar gemapt moeten worden. Hiervoor is voor ieder ieder lijnsegment uit de OSM basemap gezocht naar een 'nearest neighbor' in het NWB. Met behulp van de afstand tot de nearest neighbor kunnen afwijkingen worden gedetecteerd. Voorbeeld: Objecten in de OSM basemap die geen nearest neighbor in het NWB hebben binnen een bepaalde marge kunnen duiden op missende/onjuiste informatie in het NWB. Andersom (NWB object zonder OSM nearest neighbor) duidt op een weg die wel in NWB bestaat, maar niet in de OSM basemap. Om de afstand te bepalen tussen een object in de OSM basemap en een object in NWB, is gebruik gemaakt van een afgeleide van de [Hausdorff distance](https://en.wikipedia.org/wiki/Hausdorff_distance). Hiervoor is eerst nog enige bewerking gedaan.


```{r,echo=T,eval=F}
#Eerst worden beide shapes omgezet naar RD coordinaten, t.b.v. eenheid meter
rd<- "+proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.999908 +x_0=155000 +y_0=463000 +ellps=bessel +units=m +towgs84=565.2369,50.0087,465.658,-0.406857330322398,0.350732676542563,-1.8703473836068,4.0812 +no_defs"

nwb_select<- spTransform(nwb_select,rd)
basemap_select<- spTransform(basemap_select,rd)

rm(rd)
```


##Haal dubbele OSM lijnstukken weg
Blijkbaar komen in de OSM basemap veel dubbele wegsementen voor (exact dezelfde geometrie). Het heeft geen zin om deze dubbel te checken, daarom verwijderen we ze hier.
```{r}
source('remove_doubles.r')
#maak een vector van IDs die de shape omscrijven terwijl alles maar 1 keer voorkomt
IDs = remove_doubles(basemap_select) 

i=1

#gooi alle lines die niet in de lijst van IDs voorkomen weg
while(i <= length(basemap_select@lines)){
  
  if(! (basemap_select@lines[[i]]@ID %in% IDs)){
     basemap_select<- basemap_select[-i,] 
    i=i
  }else{
    i = i+1
    if (!i%%100){print(i)}
  }
  
}

rm(IDs)
rm(i)




```


##Equidistant
Beide bestanden bestaan uit Polyline shapes, maar de OSM basemap heeft een hogere resolutie het NWB (OSM segmenten zijn max 50 m. lang, NWB segmenten vaak langer). Met name bij langere en rechte NWB segmenten (weinig onderliggende punten in de polyline) levert dat problemen op bij het bepalen van de nearest neighbor. Om dat probleem te ondervangen zijn de NWB segmenten eerst kunstmatig opgeknipt in segmenten van max 25 m.

```{r,echo=T,eval=F}
source('prepare_shape.r')
lengte = 25

#Maak NWB equidistant
nwb_select_eq<- nwb_select
x = pblapply( c(1:length(nwb_select@lines)), function(i){
  as.data.frame(spacing(pad = nwb_select_eq@lines[[i]]@Lines[[1]]@coords  ,lengte= lengte))
})


for(i in 1:length(nwb_select@lines)){
  colnames(x[[i]]) = c('x','y')
  nwb_select_eq@lines[[i]]@Lines[[1]]@coords = as.matrix(x[[i]])
}



#Maak OSM equidistant
basemap_select_eq<- basemap_select
x = pblapply( c(1:length(basemap_select@lines)), function(i){
  spacing(pad = basemap_select_eq@lines[[i]]@Lines[[1]]@coords  ,lengte= lengte)
})

for(i in 1:length(basemap_select_eq@lines)){
   colnames(x[[i]]) = c('x','y')
  basemap_select_eq@lines[[i]]@Lines[[1]]@coords = as.matrix(x[[i]])
}
rm(lengte)
rm(x)
rm(i)

```

#################################################EIND PREPROCESSING#############################################

#####################################################FEATURE ENGENEERING######################################################





##MATCHING OSM segmenten aan NWB segmenten
We berekenen per OSM line en per NWB line de afstand van alle punten op de NWB line tot alle punten of de OSM line. Vervolgens nemen we voor ieder OSM punt de minimale afstand tot de punten op de NWB line. Van deze afstanden nemen we het maximum. Dit noemen we de half-hausdorf afstand tussen de twee lines. Voor idere OSM line matchen we de NWB line met de kleinste half-hausdorf afstand.

 

```{r,echo=T,eval=F,cache=T}

basemap_select_eq$segmentID<- as.integer(as.character(basemap_select_eq$segmentID))
source('half_hausdorf.r')

distance_lijst_OSM = pblapply(c(1:length(basemap_select_eq@lines)), function(i){
  
  hausdorf_distances_to_NWB_lines =   lapply(c(1:length(nwb_select_eq@lines)),function(j){
    mean_dist(basemap_select_eq@lines[[i]]@Lines[[1]]@coords, nwb_select_eq@lines[[j]]@Lines[[1]]@coords  )
  })
  
  
  minimum_distance_osm = min(unlist( hausdorf_distances_to_NWB_lines))
  label = which.min( unlist(hausdorf_distances_to_NWB_lines) )
  
  return( data.frame( 'OSM_ID'=  as.integer(basemap_select_eq$segmentID[i]), 'WVK_ID'=  as.integer(as.numeric(as.character(nwb_select_eq$WVK_ID[label]))), 'dist' = minimum_distance_osm))
})


distance_lijst_OSM = rbindlist(distance_lijst_OSM)

basemap_select@data$'afstand_nwb_lijn' <- distance_lijst_OSM$dist[match(basemap_select@data$segmentID , distance_lijst_OSM$OSM_ID)]
basemap_select@data$'nearest_nwb_line_id' <- distance_lijst_OSM$WVK_ID[match(basemap_select@data$segmentID , distance_lijst_OSM$OSM_ID)]

rm(distance_lijst_OSM)


```




##afstanden juncties NWB tot juncties OSM
Vind de juncties en bepaal voor iedere junctie in OSM het dichtsbijzijnde junctie in NWB en andersom


```{r,cache=TRUE}

#VUL HIER NIET DE EQUIDISTANTE SHAPE IN MAAR DE ORGINELE SHAPES!
source('vind_juncties.r')


#vind coordinaten van juncties in het OSM en het NWB



OSM_juncties = vind_juncties(basemap_select, osm = TRUE)
NWB_juncties = vind_juncties(nwb_select, osm = FALSE)




#vind voor iedere NWB junctie de dichtsbijzijnde OSM junctie
dichtst_bijzijnde_OSM_junctie =  pblapply(c(1:nrow(NWB_juncties)), function(i){
 dist =  sqrt ( (OSM_juncties[,1] - as.numeric(NWB_juncties[i,1])   )^2   +   (OSM_juncties[,2] - as.numeric(NWB_juncties[i,2])  )^2 )
 buren = OSM_juncties[dist == min(dist),]
 x = data.frame( 'x_osm' =  buren[1,1], 'y_osm' =  buren[1,2], 'id_osm' = buren[1,3], 'dist_osm' = min(dist))
 
 return(x)
 
})

#zet in een dataframe
dichtst_bijzijnde_OSM_junctie =  rbindlist(dichtst_bijzijnde_OSM_junctie)
juncties = cbind(NWB_juncties, dichtst_bijzijnde_OSM_junctie  )
colnames(juncties) = c('x_NWB', 'y_NWB', 'WVK_ID', 'x_osm', 'y_OSM', 'id_osm', 'dist')

matrix_juncties = juncties
rm(juncties)
rm(dichtst_bijzijnde_OSM_junctie)
rm(NWB_juncties)
rm(OSM_juncties)

nwb_select@data$'afstand_osm_splitsing' <- matrix_juncties$dist[match(nwb_select@data$WVK_ID , matrix_juncties$WVK_ID)]
rm(juncties)
rm(matrix_juncties)

```

##Afwijking NWB lijn tot basmap shape
Vind voor alle punten op een NWB segment de dichtsbijzijnde punten van OSM. Kijk of het maximum en het gemiddelde niet tever afwijken.


```{r,echo=T,eval=F,cache=T}
#GEBRUIK NU WEL EQUIDISTANTE SHAPES

#zet alle punten van OSM in een dataframe
OSM = basemap_select_eq
NWB = nwb_select_eq

points_OSM = pblapply(c(1:length(OSM@lines)), function(i){
  as.data.frame(OSM@lines[[i]]@Lines[[1]]@coords)
})
points_OSM = rbindlist(points_OSM)
points_OSM = points_OSM[!duplicated(points_OSM),]


#loop door alle NWB lines heen en bereken de min, max en mean tot de points
distance_matrix = pblapply(1:length(NWB@lines), function(i){
  
  distances = lapply(1:nrow(NWB@lines[[i]]@Lines[[1]]@coords ), function(j){
     min(sqrt(  ( (points_OSM$x - NWB@lines[[i]]@Lines[[1]]@coords[j,1])^2 + (points_OSM$y - NWB@lines[[i]]@Lines[[1]]@coords[j,2])^2) ) )
    
  })
  distances = unlist(distances)
  return( data.frame( 'WVK_ID' = as.numeric(as.character(NWB@data$WVK_ID[i])), 'max' =  max(distances), 'min' = min(distances) , 'mean' = mean(distances), 'median' =  median(distances)  ))
  
})

distance_matrix = rbindlist(distance_matrix)



nwb_select@data$'max_afstand_osm' <- distance_matrix$max[match(nwb_select$WVK_ID,distance_matrix$WVK_ID)]
nwb_select@data$'min_afstand_osm' <- distance_matrix$min[match(nwb_select$WVK_ID,distance_matrix$WVK_ID)]
nwb_select@data$'mean_afstand_osm' <- distance_matrix$mean[match(nwb_select$WVK_ID,distance_matrix$WVK_ID)]
nwb_select@data$'median_afstand_osm' <- distance_matrix$median[match(nwb_select$WVK_ID,distance_matrix$WVK_ID)]

rm(distance_matrix)
rm(OSM)
rm(NWB)
rm(points_OSM)

```

########################################################EIND FEATURE ENGINEERING#################################################################






########################################FOUTEN OPSPOREN#################################

####hier alleen nwb_select en basemap_select gebruiken als input

#######################################EIND FOUTEN OPSPOREN############################################





##Merge metadata
Metadata uit OSM en NWB met elkaar vergelijken op basis van de beschikbare gegevens uit NWB, WEGGEG/WKD en de metadata uit de aangeleverde basemap (OSM).
```{r}
vmax_weggeg <- read.dbf("db/WEGGEG/01-06-2017/Maximum snelheid/max_snelheden.dbf")
vmax_weggeg<- vmax_weggeg[!duplicated(vmax_weggeg$WVK_ID),] #remove segments with >1 max speed

vmax_wkd<- read.csv("db/WKD/01-06-2017/Speed/Wegvakdeel N/MAX_SNELHEDEN.csv",sep="\t")
#vmax_wkd2<- read.csv("db/WKD/01-06-2017/Speed/Wegvakdeel J/MAX_SNELHEDEN.csv",sep="\t")
#vmax_wkd<- rbind(vmax_wkd,vmax_wkd2);rm(vmax_wkd2)
vmax_wkd$OMSCHR<- as.numeric(gsub("\\D", "", vmax_wkd$HDE_SHT))
vmax_wkd$WVK_ID<- vmax_wkd$WEGVAK_ID

vmax_merged<- rbind(vmax_weggeg[,c('WVK_ID','OMSCHR')],vmax_wkd[,c('WVK_ID','OMSCHR')])



nwb_select$vmax<- vmax_weggeg$OMSCHR[match(nwb_select$WVK_ID,vmax_merged$WVK_ID)]
nwb_select_wgs$vmax<- vmax_weggeg$OMSCHR[match(nwb_select_wgs$WVK_ID,vmax_merged$WVK_ID)]
```


##Floating car data samenvoegen
Dit stuk code leest alle tabellen van de floatin car data en maakt er een tabel van met 4 kolommen. Het wegsegment ID, de gemiddeld gereden snelheid, het aantal tabellen waarin het segement voorkomt en de cummulatieve intensiteit. Deze tabel word gemaakt voor 6-19 en 19-6 om rekening te houden met wisseling in maximum snelheid. NB dit gebeurt in het bestandje aggregeer_fcd.R

```{r}

#base_full=read.dbf("db/basemaps/13354-shapes/segments.dbf")

source('merge_fcd.r')


dagen<- c("01","02","03","04","05","06",
  "07","08","09" ,"10")


# for (dag in dagen){
#   dir = paste0('db/06/',dag)
#   uur1 = 9
#   uur2 = 19
# 
#   tabel_overdag <- merge_tables(dir = dir,uur1 = uur1, uur2 = uur2)
#   save(tabel_overdag,file=paste0('db/fcd_agg/',dag,'_dag.RData'))
#   tabel_nacht =  merge_tables(dir = dir,uur1 = uur2, uur2 = uur1)
#   save(tabel_nacht,file=paste0('db/fcd_agg/',dag,'_nacht.RData'))
# }



#aggregeer en match aan NWB
dagen<- Sys.glob('db/fcd_agg/*dag.RData',dirmark = F)
nachten<-  Sys.glob('db/fcd_agg/*nacht.RData',dirmark = F)

dag<- rbindlist(lapply(dagen,function(d){load(d);return(tabel_overdag)}))
nacht<- rbindlist(lapply(nachten,function(d){load(d);return(tabel_nacht)}))


#aggregate
dag_agg <- dag %>% group_by(SegmentID) %>%
  summarise(
  aantal = sum(aantal_keer_totaal,na.rm=TRUE),
  v_mean = mean(SpeedKph, na.rm = TRUE),
  v_max = max(SpeedKph, na.rm=TRUE))


dag_agg$perc_coverage <- dag_agg$aantal/(10*11*60) #11 uur per dag, 10 dagen, 60 minuten/uur

#remove segments with no traffic
dag_agg<- dag_agg[which(dag_agg$aantal>0),]


#aggregate snelheden 's nachts
nacht_agg <- nacht %>% group_by(SegmentID) %>%
  summarise(
  aantal = sum(aantal_keer_totaal,na.rm=TRUE),
  v_mean = mean(SpeedKph, na.rm = TRUE),
  v_max = max(SpeedKph, na.rm=TRUE))
  
nacht_agg$perc_coverage <- nacht_agg$aantal/(10*13*60) #13 uur per nacht, 10 nachten, 60 minuten/uur

#remove segments with no traffic
nacht_agg<- nacht_agg[which(nacht_agg$aantal>0),]

```

Voeg samen en visualiseer

```{r}
nwb_select$v_mean_dag<- dag_agg$v_mean[match(nwb_select$nn_OSM,dag_agg$SegmentID)]
nwb_select$dekking<- dag_agg$perc_coverage[match(nwb_select$nn_OSM,dag_agg$SegmentID)]

nwb_select_wgs$v_mean_dag<- dag_agg$v_mean[match(nwb_select_wgs$nn_OSM,dag_agg$SegmentID)]
nwb_select_wgs$dekking<- dag_agg$perc_coverage[match(nwb_select_wgs$nn_OSM,dag_agg$SegmentID)]

basemap_select$v_mean_dag<- dag_agg$v_mean[match(basemap_select$segmentID,dag_agg$SegmentID)]
basemap_select$dekking<- dag_agg$perc_coverage[match(basemap_select$segmentID,dag_agg$SegmentID)]

basemap_select_wgs$v_mean_dag<- dag_agg$v_mean[match(basemap_select_wgs$segmentID,dag_agg$SegmentID)]
basemap_select_wgs$dekking<- dag_agg$perc_coverage[match(basemap_select_wgs$segmentID,dag_agg$SegmentID)]
basemap_select_wgs$dekking<- ifelse(is.na(basemap_select_wgs$dekking),0, basemap_select_wgs$dekking)
basemap_select_wgs$dekking_scale<- 0.2+(basemap_select_wgs$dekking*0.8)/(1-0.2) #scale between 0.2 and 1

  
##leaflet
leaflet() %>% addProviderTiles(providers$CartoDB)  %>% 
  addPolylines(data=nwb_select_wgs,opacity=0.4,col=~factpal_nwb(is_nn50),
               popup=~paste("WVK_ID: ",WVK_ID,"<br>",
                            "dist: ", hh_dist),
               group="NWB",highlightOptions=highlightOptions(fillOpacity = 1,
                              bringToFront = TRUE) ) %>% 
  addPolylines(data=basemap_select_wgs,weight = 8,opacity=~dekking_scale,col=~factpal(ge50),group="OSM",
               popup= ~paste("SegmentID:",segmentID, "<br>",
                             "nn_nwb: ",nn_nwb_half, "<br>",
                             "half_hausdorff: ", hh_dist,"<br>",
                             "dekking: ",dekking),highlightOptions=highlightOptions(fillOpacity = 1,
                              bringToFront = TRUE)) %>%
  # Layers control
  addLayersControl(
    overlayGroups = c("NWB", "OSM"),
    options = layersControlOptions(collapsed = FALSE)) %>%

    addLegend("bottomright", colors = c("chartreuse","black","blue","red"), labels = c("Wel in OSM, ook in NWB","Wel in OSM, niet NWB",
                                                                                  "Wel in NWB, ook in OSM","Wel in NWB, niet in OSM"),
    title = "Legend",
    opacity = 0.7)
  


```

Check equidistante shapes
```{r}
test<- nwb_select_eq[which(nwb_select_eq$WVK_ID == 209298002),]
test@lines

test2<- nwb_select[which(nwb_select$WVK_ID == 209298002),]
test2@lines
```








##Leaflet om verschillen inzichtelijk te maken
```{r}


#distance_matrix_OSM$ge50<- ifelse(distance_matrix_OSM$Half_Hausdorfdistance >=50, TRUE,FALSE) #hh distance greater than or equal to 50 m

#merge
basemap_select$nn_nwb_half<- distance_matrix_OSM$NWB_id[match(basemap_select$segmentID,distance_matrix_OSM$OSM_id)]
basemap_select$hh_dist<- distance_matrix_OSM$Half_Hausdorfdistance[match(basemap_select$segmentID,distance_matrix_OSM$OSM_id)]
basemap_select$ge50<- ifelse(basemap_select$hh_dist >=50, TRUE,FALSE)


nwb_select$is_nn50<- ifelse(nwb_select$WVK_ID %in% basemap_select$nn_nwb_half[basemap_select$hh_dist<50],FALSE,TRUE )
nwb_select$nn_OSM<- distance_matrix_OSM$OSM_id[match(nwb_select$WVK_ID,distance_matrix_OSM$NWB_id)]
nwb_select$hh_dist<- distance_matrix_OSM$Half_Hausdorfdistance[match(nwb_select$WVK_ID,distance_matrix_OSM$NWB_id)]


nwb_select$mean_dist<- distance_matrix$mean[match(nwb_select$WVK_ID,distance_matrix$ID)]
nwb_select$min_dist<- distance_matrix$min[match(nwb_select$WVK_ID,distance_matrix$ID)]
nwb_select$max_dist<- distance_matrix$max[match(nwb_select$WVK_ID,distance_matrix$ID)]
nwb_selectmed_dist<- distance_matrix$median[match(nwb_select$WVK_ID,distance_matrix$ID)]

nwb_select$mean25<- ifelse(nwb_select$mean_dist>=25,TRUE,FALSE)

# nwb_select$nn_OSM<- distance_matrix_NWB$OSM_id[match(nwb_select$WVK_ID,distance_matrix_NWB$NWB_id)]
# nwb_select$hh_dist<- distance_matrix_NWB$Half_Hausdorfdistance[match(nwb_select$WVK_ID,distance_matrix_NWB$NWB_id)]
# nwb_select$ge50<- ifelse(nwb_select$hh_dist >=50, TRUE, FALSE)

##back to wgs for plotting
wgs<- "+proj=longlat +ellps=WGS84 +datum=WGS84 +towgs84=0,0,0"

basemap_select_wgs<- spTransform(basemap_select,wgs)
nwb_select_wgs<- spTransform(nwb_select,wgs)

basemap_select_wgs<- basemap_select_wgs[order(basemap_select_wgs$nn_nwb_half),]
nwb_select_wgs<- nwb_select_wgs[order(nwb_select_wgs$WVK_ID),]


#export for shiny
#save(basemap_select_wgs,file="db/basemap_select_wgs.RData")
#save(nwb_select_wgs,file="db/nwb_select_wgs.RData")
#save(distance_matrix,file="db/dist_matrix.RData")

factpal <- colorFactor(c("green","black"), c(TRUE,FALSE))
factpal_nwb <- colorFactor(c("blue","red"), c(TRUE,FALSE))

##leaflet
leaflet() %>% addProviderTiles(providers$CartoDB)  %>% 
  addPolylines(data=nwb_select_wgs,opacity=0.5,col=~factpal_nwb(mean25),
               popup=~paste("WVK_ID: ",WVK_ID,"<br>",
                            "dist: ", hh_dist),
               group="NWB",highlightOptions=highlightOptions(fillOpacity = 1,
                              bringToFront = TRUE) ) %>% 
  addPolylines(data=basemap_select_wgs,weight = 5,opacity=0.5,col=~factpal(ge50),group="OSM",
               popup= ~paste("SegmentID:",segmentID, "<br>",
                             "nn_nwb: ",nn_nwb_half, "<br>",
                             "half_hausdorff: ", hh_dist),highlightOptions=highlightOptions(fillOpacity = 1,
                              bringToFront = TRUE)) %>%
  # Layers control
  addLayersControl(
    overlayGroups = c("NWB", "OSM"),
    options = layersControlOptions(collapsed = FALSE)) %>%

    addLegend("bottomright", colors = c("chartreuse","black","blue","red"), labels = c("Wel in OSM, ook in NWB","Wel in OSM, niet NWB",
                                                                                  "Wel in NWB, ook in OSM","Wel in NWB, niet in OSM"),
    title = "Legend",
    opacity = 0.7)
  

#######################################3
#visualiseer juncties



python.load("omrekenen.py")



  
  juncties = lapply( 1:nrow(matrix_juncties), function(i){
    
   coords = data.frame('id' = matrix_juncties$id_nwb[i], 'dist' = matrix_juncties$dist[i] )
     
     
    python.assign('coords', c( matrix_juncties$x_NWB[i], matrix_juncties$y_NWB[i] ) )
  python.exec('wgsCoords = conv.fromRdToWgs( coords )')

 coords$lat_nwb = python.get('wgsCoords')[1]
 coords$lon_nwb = python.get('wgsCoords')[2]
  
 
  
   python.assign('coords', c( matrix_juncties$x_osm[i], matrix_juncties$y_OSM[i] ) )
python.exec('wgsCoords = conv.fromRdToWgs( coords )')

 coords$lat_osm = python.get('wgsCoords')[1]
 coords$lon_osm = python.get('wgsCoords')[2]
 
 return(coords)
  })
  
  juncties = rbindlist(juncties)


m = leaflet()
m = addProviderTiles(m,providers$CartoDB)
m = addCircleMarkers(m, lat = juncties$lat_nwb , lng = juncties$lon_nwb, color ='blue', popup = paste( '<h> dist:', juncties$dist , 'id:', juncties$id , '</h>' ) )
m = addCircleMarkers(m, lat = juncties$lat_osm , lng = juncties$lon_osm, color ='red', popup = paste( '<h> dist:', juncties$dist , 'id:', juncties$id , '</h>' ) )

print(m)

```
