---
title: "NWB_FCD project"
output: html_notebook
---

Project in opdracht van NWB projectteam, uitgevoerd door RWS Datalab.

Team:  
[Martijn Koole](martijn.koole@rws.nl) - Data Scientist  
[Daan van der Maas](daan.vander.maas@rws.nl) - Data Scientist  
[Jan Quist](jan.quist@rws.nl) - Data Scientist  
[Steven van Gelder](steven.van.gelder@rws.nl) - Product manager  
[Vikash Rambaran](vikash.rambaran@rws.nl) - Product Owner  


#Data laden en preprocessing
Onderstaande code importeert alle benodigde libraries en functies en laadt vervolgens de gebruikte data. Er is een uitsnede gemaakt van het NWB Wegvakken bestand van 01-06-2017 rondom Gouda. Vervolgens is een zelfde uitsnede gemaakt voor de Basemap die verkregen is via BeMobile (gebaseerd op Open Street Map, OSM). De uitsnede is in eerste instantie gemaakt om de rekentijd kort te houden tijdens ontwikkelen/testen. Dat gebeurt in het script read_fcd.R. Later kunnen dezelfde scripts gebruikt worden voor om over heel Nederland verschillen te detecteren.

```{r, echo=F,cache=T,eval=F}
source('lib.r')
load("db/basemap_select.RData")
load("db/nwb_select2.RData")
```

Om het NWB bestand te kunnen vergelijken zullen deze op elkaar gemapt moeten worden. Hiervoor is voor ieder ieder lijnsegment uit de OSM basemap gezocht naar een 'nearest neighbor' in het NWB. Met behulp van de afstand tot de nearest neighbor kunnen afwijkingen worden gedetecteerd. Voorbeeld: Objecten in de OSM basemap die geen nearest neighbor in het NWB hebben binnen een bepaalde marge kunnen duiden op missende/onjuiste informatie in het NWB. Andersom (NWB object zonder OSM nearest neighbor) duidt op een weg die wel in NWB bestaat, maar niet in de OSM basemap. Om de afstand te bepalen tussen een object in de OSM basemap en een object in NWB, is gebruik gemaakt van een afgeleide van de [Hausdorff distance](https://en.wikipedia.org/wiki/Hausdorff_distance). Hiervoor is eerst nog enige bewerking gedaan.


```{r,echo=T,eval=F}
#Eerst worden beide shapes omgezet naar RD coordinaten, t.b.v. eenheid meter
rd<- "+proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.999908 +x_0=155000 +y_0=463000 +ellps=bessel +units=m +towgs84=565.2369,50.0087,465.658,-0.406857330322398,0.350732676542563,-1.8703473836068,4.0812 +no_defs"

nwb_select<- spTransform(nwb_select,rd)
basemap_select<- spTransform(basemap_select,rd)

```

##Equidistant
Beide bestanden bestaan uit Polyline shapes, maar de OSM basemap heeft een hogere resolutie het NWB (OSM segmenten zijn max 50 m. lang, NWB segmenten vaak langer). Met name bij langere en rechte NWB segmenten (weinig onderliggende punten in de polyline) levert dat problemen op bij het bepalen van de nearest neighbor. Om dat probleem te ondervangen zijn de NWB segmenten eerst kunstmatig opgeknipt in segmenten van max 50 m.

```{r,echo=T,eval=F}
source('prepare_shape.r')
lengte = 25

#Maak NWB equidistant
nwb_select_eq<- nwb_select
x = pblapply( c(1:length(nwb_select@lines)), function(i){
  as.data.frame(spacing(pad = nwb_select_eq@lines[[i]]@Lines[[1]]@coords  ,lengte= lengte))
})


for(i in 1:length(nwb_select@lines)){
  colnames(x[[i]]) = c('x','y')
  nwb_select_eq@lines[[i]]@Lines[[1]]@coords = as.matrix(x[[i]])
}



#Maak OSM equidistant
basemap_select_eq<- basemap_select
x = pblapply( c(1:length(basemap_select@lines)), function(i){
  spacing(pad = basemap_select_eq@lines[[i]]@Lines[[1]]@coords  ,lengte= lengte)
})

for(i in 1:length(basemap_select_eq@lines)){
   colnames(x[[i]]) = c('x','y')
  basemap_select_eq@lines[[i]]@Lines[[1]]@coords = as.matrix(x[[i]])
}



```

##MATCH lines door middel van mean distance
We berekenen per OSM line en per NWB line de afstand van alle punten op de NWB line tot alle punten of de OSM line. Vervolgens nemen we voor ieder OSM punt de minimale afstand tot de punten op de NWB line. Van deze afstanden nemen we het maximum. Dit noemen we de half-hausdorf afstand tussen de twee lines. Voor idere OSM line matchen we de NWB line met de kleinste half-hausdorf afstand.

 

```{r,echo=T,eval=F,cache=T}

basemap_select_eq$segmentID<- as.integer(as.character(basemap_select_eq$segmentID))
source('half_hausdorf.r')
OSM = basemap_select_eq
NWB = nwb_select_eq

distance_lijst_OSM = pblapply(c(1:length(OSM@lines)), function(i){
  
  hausdorf_distances_to_NWB_lines =   lapply(c(1:length(NWB@lines)),function(j){
    mean_dist(OSM@lines[[i]]@Lines[[1]]@coords, NWB@lines[[j]]@Lines[[1]]@coords  )
  })
  
  
  minimum_distance_osm = min(unlist( hausdorf_distances_to_NWB_lines))
  label = which.min( unlist(hausdorf_distances_to_NWB_lines) )
  
  return(c(OSM$segmentID[i],as.numeric(as.character(NWB$WVK_ID[label])), minimum_distance_osm))
})

distance_lijst_NWB = pblapply(c(1:length(NWB@lines)), function(i){
    hausdorf_distances_to_OSM_lines =   lapply(c(1:length(OSM@lines)),function(j){
    mean_dist(NWB@lines[[i]]@Lines[[1]]@coords, OSM@lines[[j]]@Lines[[1]]@coords  )
  })
  
  minimum_distance_nwb = min(unlist( hausdorf_distances_to_NWB_lines))
  label = which.min( unlist(hausdorf_distances_to_NWB_lines) )
  
  return(c(NWB$WVK_ID[i],as.numeric(as.character(OSM$segmentID[label])), minimum_distance_nwb))
})

#create df with nearest neighbors
distance_matrix_OSM = as.data.frame(do.call(rbind, distance_lijst_OSM))[,c(1:3)]
colnames(distance_matrix_OSM) = c('OSM_id', 'NWB_id', 'Half_Hausdorfdistance')

#create df with nearest neighbors
distance_matrix_NWB = as.data.frame(do.call(rbind, distance_lijst_NWB))[,c(1:3)]
colnames(distance_matrix_NWB) = c('NWB_id', 'OSM_id', 'Half_Hausdorfdistance')

```

##Leaflet om verschillen inzichtelijk te maken
```{r}


distance_matrix$ge50<- ifelse(distance_matrix$Half_Hausdorfdistance >=50, TRUE,FALSE) #hh distance greater than or equal to 50 m

#merge
basemap_select$nn_nwb_half<- distance_matrix$NWB_id[match(basemap_select$segmentID,distance_matrix$OSM_id)]
basemap_select$ge50<- distance_matrix$ge50[match(basemap_select$segmentID,distance_matrix$OSM_id)]
basemap_select$hh_dist<- distance_matrix$Half_Hausdorfdistance[match(basemap_select$segmentID,distance_matrix$OSM_id)]

nwb_select$is_nn50<- ifelse(nwb_select$WVK_ID %in% basemap_select$nn_nwb_half[basemap_select$hh_dist<50],TRUE,FALSE )

##back to wgs for plotting
wgs<- "+proj=longlat +ellps=WGS84 +datum=WGS84 +towgs84=0,0,0"

basemap_select_wgs<- spTransform(basemap_select,wgs)
nwb_select_wgs<- spTransform(nwb_select,wgs)

basemap_select_wgs<- basemap_select_wgs[order(basemap_select_wgs$nn_nwb_half),]
nwb_select_wgs<- nwb_select_wgs[order(nwb_select_wgs$WVK_ID),]


#export for shiny
#save(basemap_select_wgs,file="db/basemap_select_wgs.RData")
#save(nwb_select_wgs,file="db/nwb_select_wgs.RData")
#save(distance_matrix,file="db/dist_matrix.RData")

factpal <- colorFactor(c("green","black"), c(TRUE,FALSE))
factpal_nwb <- colorFactor(c("red","blue"), c(TRUE,FALSE))

##leaflet
leaflet() %>% addProviderTiles(providers$CartoDB)  %>% 
  addPolylines(data=nwb_select_wgs,opacity=0.5,col=~factpal_nwb(is_nn50),
               popup=~paste("WVK_ID: ",WVK_ID),group="NWB",highlightOptions=highlightOptions(fillOpacity = 1,
                              bringToFront = TRUE) ) %>% 
  addPolylines(data=basemap_select_wgs,weight = 5,opacity=0.5,col=~factpal(ge50),group="OSM",
               popup= ~paste("SegmentID:",segmentID, "<br>",
                             "nn_nwb: ",nn_nwb_half, "<br>",
                             "half_hausdorff: ", hh_dist),highlightOptions=highlightOptions(fillOpacity = 1,
                              bringToFront = TRUE)) %>%
  # Layers control
  addLayersControl(
    overlayGroups = c("NWB", "OSM"),
    options = layersControlOptions(collapsed = FALSE)) %>%

    addLegend("bottomright", colors = c("chartreuse","black","blue","red"), labels = c("Wel in OSM, ook in NWB","Wel in OSM, niet NWB",
                                                                                  "Wel in NWB, ook in OSM","Wel in NWB, niet in OSM"),
    title = "Legend",
    opacity = 0.7)
  

```



##Juncties van OSM en NWB vergelijken
Vind de juncties en bepaal voor iedere junctie in OSM het dichtsbijzijnde junctie in NWB en andersom


```{r}

#VUL HIER NIET DE EQUIDISTANTE SHAPE IN MAAR DE ORGINELE SHAPES!
source('vind_juncties.r')



OSM_juncties = vind_juncties(basemap_select)
NWB_juncties = vind_juncties(nwb_select)

dichtst_bijzijnde_NWB_junctie =  pblapply(c(1:nrow(OSM_juncties)), function(i){
 x =  sqrt ( (NWB_juncties[,1] - OSM_juncties[i,1])^2   +   (NWB_juncties[,2] - OSM_juncties[i,2])^2 )
 x = NWB_juncties[x == min(x),] 
 return(x[1,])
 
})

dichtst_bijzijnde_NWB_junctie =  do.call(rbind, dichtst_bijzijnde_NWB_junctie)
OSM_juncties = cbind(OSM_juncties, dichtst_bijzijnde_NWB_junctie )
colnames(OSM_juncties) = c('x_OSM', 'y_OSM', 'x_NWB', 'y_NWB')


dichtst_bijzijnde_OSM_junctie =  pblapply(c(1:nrow(NWB_juncties)), function(i){
 x =  sqrt ( (OSM_juncties[,1] - NWB_juncties[i,1])^2   +   (OSM_juncties[,2] - NWB_juncties[i,2])^2 )
 x = OSM_juncties[x == min(x),] 
 
 return(x[1,])
 
})

dichtst_bijzijnde_OSM_junctie =  do.call(rbind, dichtst_bijzijnde_OSM_junctie)
NWB_juncties = cbind(dichtst_bijzijnde_NWB_junctie , OSM_juncties )
colnames(NWB_juncties) = c('x_NWB', 'y_NWB', 'x_OSM', 'y_OSM')


```

##Vind afwijkende vormen doormiddeln van de hausdorf distance
Vind voor alle punten op een NWB segment de dichtsbijzijnde punten van OSM. Kijk of het maximum en het gemiddelde niet tever afwijken.


```{r,echo=T,eval=F,cache=T}
#GEBRUIK NU WEL EQUIDISTANTE SHAPES

#zet alle punten van OSM in een dataframe
OSM = basemap_select_eq
NWB = nwb_select_eq

points_OSM = pblapply(c(1:length(OSM@lines)), function(i){
  as.data.frame(OSM@lines[[i]]@Lines[[1]]@coords)
})
points_OSM = rbindlist(points_OSM)
points_OSM = points_OSM[!duplicated(points_OSM),]


#loop door alle NWB lines heen en bereken de min, max en mean tot de points
distance_matrix = pblapply(1:length(NWB@lines), function(i){
  
  distances = lapply(1:nrow(NWB@lines[[i]]@Lines[[1]]@coords ), function(j){
     min(sqrt(  rowSums( (points_OSM - NWB@lines[[i]]@Lines[[1]]@coords[j,])^2 ) ) )
    
  })
  distances = unlist(distances)
  return( data.frame( 'ID' = NWB@data[[i]]@WVK_ID  , 'max' =  max(distances), 'min' = min(distances) , 'mean' = mean(distances), 'median' =  median(distances)  ))
  
})

distance_matrix = rbindlist(distance_matrix)


```



##Floating car data samenvoegen
Dit stuk code leest alle tabellen van de floatin car data en maakt er een tabel van met 4 kolommen. Het wegsegment ID, de gemiddeld gereden snelheid, het aantal tabellen waarin het segement voorkomt en de cummulatieve intensiteit. Deze tabel word gemaakt voor 6-19 en 19-6 om rekening te houden met wisseling in maximum snelheid. NB dit gebeurt in het bestandje aggregeer_fcd.R

```{r}
library(foreign)
base_full=read.dbf("db/basemaps/13354-shapes/segments.dbf")

source('merge_fcd.r')


#dir = 'db/06/01'
uur1 = 6
uur2 = 19

tabel_overdag = merge_tables(dir = dir,uur1 = uur1, uur2 = uur2)
tabel_nacht =  merge_tables(dir = dir,uur1 = uur2, uur2 = uur1)

```



##vind doodlopende wegen
Er komen soms kleine onterechte aftakkingen voor in het NWB om die op te kunnen sporen vergelijken we expleciet de doodlopende wegen van het NWB met het OSM.

```{r}


  rand = data.frame('x'= -1, 'y' = -1)

 for(i in 1:length(nwb_select@lines)){

    nieuw = nwb_select@lines[[i]]@Lines[[1]]@coords
    colnames(nieuw) = c('x','y')
    rand_nieuw = rbind(nieuw[1,] ,nieuw[nrow(nieuw),])
    
    rand = rbind(rand, rand_nieuw)
  
 }
rand = rand[-1,]

doodlopend_nwb = rand[!duplicated(rand),]


  rand = data.frame('x'= -1, 'y' = -1)

 for(i in 1:length(basemap_select@lines)){

    nieuw = basemap_select@lines[[i]]@Lines[[1]]@coords
    colnames(nieuw) = c('x','y')
    rand_nieuw = rbind(nieuw[1,] ,nieuw[nrow(nieuw),])
    
    rand = rbind(rand, rand_nieuw)
  
 }
rand = rand[-1,]

doodlopend_osm = rand[!duplicated(rand),]




```

